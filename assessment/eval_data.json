[
  {
    "filePath": "db/db.go",
    "code_content": "package dao\n\nimport (\n\t\"database/sql\"\n\t\"example.com/project/db\"\n\t\"example.com/project/model\"\n)\n\nfunc CreateProduct(product model.Product) (int64, error) {\n\tquery := \"INSERT INTO products (name, price) VALUES (?, ?)\"\n\tresult, err := db.DB.Exec(query, product.Name, product.Price)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn result.LastInsertId()\n}\n\nfunc GetProductByID(id int64) (*model.Product, error) {\n\tquery := \"SELECT id, name, price FROM products WHERE id = ?\"\n\trow := db.DB.QueryRow(query, id)\n\tvar product model.Product\n\tif err := row.Scan(&product.ID, &product.Name, &product.Price); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn &product, nil\n}\n",
    "source_schema": "CREATE TABLE products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);",
    "target_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind='bit_reversed_positive');\n CREATE TABLE products (\n    id INT64 DEFAULT (NEXT VALUE FOR ProductIdSequence),\n    name STRING(255) NOT NULL,\n    price FLOAT64 NOT NULL,\n) PRIMARY KEY (id);\n",
    "ground_truth": ["10", "15"]
  },
  {
    "filePath": "internal/repository/product_repo.go",
    "code_content": "package repository\n\nimport (\n\t\"database/sql\"\n\t\"example.com/project/internal/model\"\n\t\"log\"\n)\n\nvar db *sql.DB\n\nfunc SetDB(database *sql.DB) {\n\tdb = database\n}\n\n// CreateProduct inserts a new product into the database.\nfunc CreateProduct(product *model.Product) (int64, error) {\n\tquery := `INSERT INTO products\n\t\t(name, price)\n\t\tVALUES (?, ?)`\n\tresult, err := db.Exec(query, product.Name, product.Price)\n\tif err != nil {\n\t\tlog.Printf(\"DB error: %v\", err)\n\t\treturn 0, err\n\t}\n\tlastID, _ := result.LastInsertId()\n\treturn lastID, nil\n}\n\n// GetProductByID retrieves a product by its ID.\nfunc GetProductByID(id int64) (*model.Product, error) {\n\tvar product model.Product\n\trow := db.QueryRow(\n\t\t\"SELECT id, name, price FROM products WHERE id = ?\",\n\t\tid,\n\t)\n\tif err := row.Scan(&product.ID, &product.Name, &product.Price); err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn nil, nil\n\t\t}\n\t\tlog.Printf(\"DB error: %v\", err)\n\t\treturn nil, err\n\t}\n\treturn &product, nil\n}\n",
    "source_schema": "CREATE TABLE products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);",
    "target_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind='bit_reversed_positive');\n CREATE TABLE products (\n    id INT64 DEFAULT (NEXT VALUE FOR ProductIdSequence),\n    name STRING(255) NOT NULL,\n    price FLOAT64 NOT NULL,\n) PRIMARY KEY (id);\n",
    "ground_truth": ["16", "17", "18", "19"],
    "description": "Go code for basic product creation (using Exec and LastInsertId) and retrieval by ID (using QueryRow) in MySQL. Migration concerns include AUTO_INCREMENT replacement and potential float conversion for price."
  },
  {
    "filePath": "pkg/account/service.go",
    "code_content": "package account\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"example.com/project/pkg/model\"\n\t\"fmt\"\n\t\"log\"\n)\n\ntype AccountService struct {\n\tdb *sql.DB\n}\n\nfunc NewAccountService(db *sql.DB) *AccountService {\n\treturn &AccountService{db: db}\n}\n\n// Transfer performs a funds transfer between two accounts.\nfunc (s *AccountService) Transfer(ctx context.Context, fromID, toID int64, amount float64) error {\n\ttx, err := s.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"begin transaction failed: %w\", err)\n\t}\n\tdefer tx.Rollback() // Safe to call even if commit succeeds\n\n\tupdateFrom := \"UPDATE accounts SET balance = balance - ? WHERE id = ?\"\n\tif _, err = tx.ExecContext(ctx, updateFrom, amount, fromID); err != nil {\n\t\treturn fmt.Errorf(\"debit failed: %w\", err)\n\t}\n\n\tupdateTo := \"UPDATE accounts SET balance = balance + ? WHERE id = ?\"\n\tif _, err = tx.ExecContext(ctx, updateTo, amount, toID); err != nil {\n\t\treturn fmt.Errorf(\"credit failed: %w\", err)\n\t}\n\n\tif err = tx.Commit(); err != nil {\n\t\treturn fmt.Errorf(\"commit failed: %w\", err)\n\t}\n\treturn nil\n}",
    "source_schema": "CREATE TABLE accounts (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    balance DECIMAL(15,2) NOT NULL\n);",
    "target_schema": "CREATE TABLE accounts (\n    id INT64 NOT NULL,\n    balance FLOAT64 NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": [],
    "description": "Go code implementing a funds transfer as a transaction using BeginTx, ExecContext, Rollback, and Commit. Migration concerns are primarily around the shift to Spanner's transaction model and float for balance."
  },
  {
    "filePath": "internal/user/dao.go",
    "code_content": "package user\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"example.com/project/internal/model\"\n\t\"fmt\"\n)\n\n// Datastore interface for user operations.\ntype Datastore struct {\n\tdb *sql.DB\n}\n\n// NewDatastore creates a new user Datastore.\nfunc NewDatastore(db *sql.DB) *Datastore {\n\treturn &Datastore{db: db}\n}\n\n// FindByStatus retrieves users with a given status.\nfunc (d *Datastore) FindByStatus(ctx context.Context, status string) (*model.User, error) {\n\tquery := \"SELECT id, name, email FROM users WHERE status = ?\"\n\tstmt, err := d.db.PrepareContext(ctx, query)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"prepare failed: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\trows, err := stmt.QueryContext(ctx, status)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\tdefer rows.Close()\n\n\tvar users*model.User\n\tfor rows.Next() {\n\t\tvar user model.User\n\t\tif err := rows.Scan(&user.ID, &user.Name, &user.Email); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"scan failed: %w\", err)\n\t\t}\n\t\tusers = append(users, user)\n\t}\n\treturn users, nil\n}",
    "source_schema": "CREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL,\n    status VARCHAR(20) NOT NULL\n);",
    "target_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(255) NOT NULL,\n    email STRING(255) NOT NULL,\n    status STRING(20) NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": [],
    "description": "Go code using PrepareContext and QueryContext to find users by status. Migration concerns are primarily around the `database/sql` function calls, though the SQL itself is relatively standard."
  },
  {
    "filePath": "app/admin/executor.go",
    "code_content": "package admin\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Executor provides methods to execute admin commands.\ntype Executor struct {\n\tdb *sql.DB\n}\n\n// NewExecutor returns a new Executor.\nfunc NewExecutor(db *sql.DB) *Executor {\n\treturn &Executor{db: db}\n}\n\n// CallProcedure executes a stored procedure.\nfunc (e *Executor) CallProcedure(name string, args ...interface{}) error {\n\tplaceholders := make(string, len(args))\n\tfor i := range args {\n\t\tplaceholders[i] = \"?\"\n\t}\n\tquery := fmt.Sprintf(\"CALL %s(%s)\", name, strings.Join(placeholders, \",\"))\n\t_, err := e.db.Exec(query, args...)\n\treturn err\n}",
    "source_schema": "DELIMITER //\nCREATE PROCEDURE AdjustSalary(IN empId BIGINT, IN amount DECIMAL(10,2))\nBEGIN\n  UPDATE employees SET salary = salary + amount WHERE id = empId;\nEND //\nDELIMITER ;",
    "target_schema": "-- Spanner does not support stored procedures, use transactions instead\n-- Converted equivalent application logic to handle salary adjustment.",
    "ground_truth": ["21", "22"],
    "description": "Go code dynamically constructing and executing a CALL statement for a MySQL stored procedure using Exec. Stored procedures are not supported in Spanner, requiring a rewrite to application-level transactions."
  },
  {
    "filePath": "internal/order/repo.go",
    "code_content": "package order\n\nimport (\n\t\"database/sql\"\n\t\"example.com/project/internal/model\"\n\t\"fmt\"\n)\n\n// Repository handles database operations for orders.\ntype Repository struct {\n\tdb *sql.DB\n}\n\n// NewRepository creates a new OrderRepository.\nfunc NewRepository(db *sql.DB) *Repository {\n\treturn &Repository{db: db}\n}\n\n// InsertOrder creates a new order.\nfunc (r *Repository) InsertOrder(order *model.Order) (int64, error) {\n\tquery := \"INSERT INTO orders (customer_id, total_amount) VALUES (?, ?)\"\n\tresult, err := r.db.Exec(query, order.CustomerID, order.TotalAmount)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"insert failed: %w\", err)\n\t}\n\torderID, err := result.LastInsertId()\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"get last insert id failed: %w\", err)\n\t}\n\treturn orderID, nil\n}",
    "source_schema": "CREATE TABLE orders (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    customer_id BIGINT NOT NULL,\n    total_amount DECIMAL(10,2) NOT NULL\n);",
    "target_schema": "CREATE SEQUENCE OrderIdSequence OPTIONS (sequence_kind='bit_reversed_positive');\nCREATE TABLE orders (\n    id INT64 DEFAULT (NEXT VALUE FOR OrderIdSequence),\n    customer_id INT64 NOT NULL,\n    total_amount FLOAT64 NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": ["22", "26","30"],
    "description": "Go code inserting an order and retrieving the last insert ID using Exec and LastInsertId. Migration requires replacing AUTO_INCREMENT (and thus LastInsertId) with a Spanner sequence or UUID generation."
  },
  {
    "filePath": "pkg/log/cleaner.go",
    "code_content": "package log\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Cleaner handles cleaning up old log entries.\ntype Cleaner struct {\n\tdb *sql.DB\n}\n\n// NewCleaner creates a new Cleaner.\nfunc NewCleaner(db *sql.DB) *Cleaner {\n\treturn &Cleaner{db: db}\n}\n\n// DeleteOldLogs deletes logs older than a certain duration.\nfunc (c *Cleaner) DeleteOldLogs(olderThan time.Duration, limit int) error {\n\tcutoff := time.Now().Add(-olderThan)\n\tquery := fmt.Sprintf(\n\t\t\"DELETE FROM logs WHERE created_at < '%s' ORDER BY created_at LIMIT %d\",\n\t\tcutoff.Format(\"2006-01-02 15:04:05\"),\n\t\tlimit,\n\t)\n\t_, err := c.db.Exec(query)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete failed: %w\", err)\n\t}\n\treturn nil\n}",
    "source_schema": "CREATE TABLE logs (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    message TEXT,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);",
    "target_schema": "CREATE TABLE logs (\n    id INT64 NOT NULL,\n    message STRING(MAX),\n    created_at TIMESTAMP OPTIONS (allow_commit_timestamp=true),\n) PRIMARY KEY (id);",
    "ground_truth": ["23"],
    "description": "Go code constructing a DELETE statement with a MySQL-specific LIMIT clause and using a formatted timestamp for comparison. Spanner requires a different approach for limiting deletes (e.g., using a subquery with a read timestamp)."
  },
  {
    "filePath": "internal/profile/updater.go",
    "code_content": "package profile\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Updater handles updating user profiles.\ntype Updater struct {\n\tdb *sql.DB\n}\n\n// NewUpdater creates a new Updater.\nfunc NewUpdater(db *sql.DB) *Updater {\n\treturn &Updater{db: db}\n}\n\n// UpdateEmailWithJoin updates a user's email using a join with the profiles table.\nfunc (u *Updater) UpdateEmailWithJoin(ctx context.Context, userID int64, newEmail string) error {\n\tquery := `UPDATE users u\n\t\t\tINNER JOIN profiles p ON u.id = p.user_id\n\t\t\tSET u.email = ?\n\t\t\tWHERE u.id = ?`\n\t_, err := u.db.ExecContext(ctx, query, newEmail, userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update failed: %w\", err)\n\t}\n\treturn nil\n}",
    "source_schema": "CREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    email VARCHAR(255)\n);\nCREATE TABLE profiles (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    user_id BIGINT,\n    address VARCHAR(255)\n);",
    "target_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(255),\n    email STRING(255),\n) PRIMARY KEY (id);\nCREATE TABLE profiles (\n    id INT64 NOT NULL,\n    user_id INT64,\n    address STRING(255),\n) PRIMARY KEY (id), INTERLEAVE IN PARENT users;",
    "ground_truth": ["21", "22", "23", "24"],
    "description": "Go code performing an UPDATE using an INNER JOIN in MySQL. While Spanner supports joins in UPDATE statements, the structure might need adjustment, especially if interleaving is involved."
  },
  {
    "filePath": "pkg/user/creator.go",
    "code_content": "package user\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Creator handles creating or updating user records.\ntype Creator struct {\n\tdb *sql.DB\n}\n\n// NewCreator creates a new Creator.\nfunc NewCreator(db *sql.DB) *Creator {\n\treturn &Creator{db: db}\n}\n\n// CreateOrUpdate attempts to insert a user, updating if the email already exists.\nfunc (c *Creator) CreateOrUpdate(id int64, name string, email string) error {\n\tquery := `\n\t\tINSERT INTO users (id, name, email)\n\t\tVALUES (?, ?, ?)\n\t\tON DUPLICATE KEY UPDATE\n\t\t\tname = VALUES(name),\n\t\t\temail = VALUES(email)\n\t`\n\t_, err := c.db.Exec(query, id, name, email)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"create/update failed: %w\", err)\n\t}\n\treturn nil\n}",
    "source_schema": "CREATE TABLE users (\n    id BIGINT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    email VARCHAR(255) UNIQUE NOT NULL\n);",
    "target_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(255) NOT NULL,\n    email STRING(255) NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": ["21", "22", "23", "24", "25"],
    "description": "Go code using MySQL's INSERT ... ON DUPLICATE KEY UPDATE for upsert functionality. Spanner does not support this; you'd typically use a read-write transaction to check for existence and then insert or update."
  },
  {
    "filePath": "pkg/product/batch_insert.go",
    "code_content": "package product\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// BatchInserter handles inserting multiple products at once.\ntype BatchInserter struct {\n\tdb *sql.DB\n}\n\n// NewBatchInserter creates a new BatchInserter.\nfunc NewBatchInserter(db *sql.DB) *BatchInserter {\n\treturn &BatchInserter{db: db}\n}\n\n// InsertMany inserts a slice of product data.\nfunc (bi *BatchInserter) InsertMany(ctx context.Context, productsmap[string]interface{}) error {\n\tif len(products) == 0 {\n\t\treturn nil\n\t}\n\tvalueStrings := make(string, 0, len(products))\n\tvalueArgs := make(interface{}, 0, len(products)*2)\n\tfor _, product := range products {\n\t\tvalueStrings = append(valueStrings, \"(?, ?)\")\n\t\tvalueArgs = append(valueArgs, product[\"name\"], product[\"price\"])\n\t}\n\tquery := fmt.Sprintf(\n\t\t\"INSERT INTO products (name, price) VALUES %s\",\n\t\tstrings.Join(valueStrings, \",\"),\n\t)\n\t_, err := bi.db.ExecContext(ctx, query, valueArgs...)\n\treturn err\n}",
    "source_schema": "CREATE TABLE products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);",
    "target_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind='bit_reversed_positive');\n CREATE TABLE products (\n    id INT64 DEFAULT (NEXT VALUE FOR ProductIdSequence),\n    name STRING(255) NOT NULL,\n    price FLOAT64 NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": ["25", "28"],
    "description": "Go code performing a batch insert by dynamically constructing a single INSERT statement with multiple value sets. For Spanner, especially with a large number of rows, it's often better to use individual INSERT mutations within a transaction for better performance and to avoid statement size limits."
  },
  {
    "filePath": "pkg/user/retriever.go",
    "code_content": "package user\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Retriever fetches user data.\ntype Retriever struct {\n\tdb *sql.DB\n}\n\n// NewRetriever creates a new Retriever.\nfunc NewRetriever(db *sql.DB) *Retriever {\n\treturn &Retriever{db: db}\n}\n\n// GetEmailByID retrieves a user's email by their ID.\nfunc (r *Retriever) GetEmailByID(ctx context.Context, id int64) (string, error) {\n\tvar email string\n\tquery := \"SELECT email FROM users WHERE id = ?\"\n\terr := r.db.QueryRowContext(ctx, query, id).Scan(&email)\n\tif err != nil {\n\t\tif err == sql.ErrNoRows {\n\t\t\treturn \"\", fmt.Errorf(\"user %d not found\", id)\n\t\t}\n\t\treturn \"\", fmt.Errorf(\"query failed: %w\", err)\n\t}\n\treturn email, nil\n}",
    "source_schema": "CREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    email VARCHAR(255)\n);",
    "target_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(255),\n    email STRING(255),\n) PRIMARY KEY (id);",
    "ground_truth": [],
    "description": "Go code retrieving a user's email using QueryRowContext. The SQL is standard, but the `database/sql` function call is a point of interest for migration."
  },
  {
    "filePath": "pkg/order/detail_fetcher.go",
    "code_content": "package order\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// DetailFetcher retrieves order details, potentially joining with customer info.\ntype DetailFetcher struct {\n\tdb *sql.DB\n}\n\n// NewDetailFetcher creates a new DetailFetcher.\nfunc NewDetailFetcher(db *sql.DB) *DetailFetcher {\n\treturn &DetailFetcher{db: db}\n}\n\n// GetDetails fetches order details for a given order ID.\nfunc (df *DetailFetcher) GetDetails(ctx context.Context, orderID int64) (map[string]interface{}, error) {\n\tquery := `SELECT o.id, c.name, o.total_amount\n\t\t\tFROM orders o\n\t\t\tJOIN customers c ON o.customer_id = c.id\n\t\t\tWHERE o.id = ?`\n\trow := df.db.QueryRowContext(ctx, query, orderID)\n\tvar details map[string]interface{}\n\tvar id int64\n\tvar customerName string\n\tvar totalAmount float64\n\tif err := row.Scan(&id, &customerName, &totalAmount); err != nil {\n\t\treturn nil, fmt.Errorf(\"scan failed: %w\", err)\n\t}\n\tdetails = map[string]interface{}{\"id\": id, \"customer\": customerName, \"amount\": totalAmount}\n\treturn details, nil\n}",
    "source_schema": "CREATE TABLE orders (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    customer_id BIGINT NOT NULL,\n    total_amount DECIMAL(10,2) NOT NULL\n);\nCREATE TABLE customers (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL\n);",
    "target_schema": "CREATE TABLE orders (\n    id INT64 NOT NULL,\n    customer_id INT64 NOT NULL,\n    total_amount FLOAT64 NOT NULL,\n) PRIMARY KEY (id);\nCREATE TABLE customers (\n    id INT64 NOT NULL,\n    name STRING(255) NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": ["22", "23","24"],
    "description": "Go code performing a SELECT with a JOIN using QueryRowContext. Spanner supports JOINs, so the migration focus is on the `database/sql` call and potential schema differences (e.g., interleaving)."
  },
  {
    "filePath": "internal/inventory/stock_manager.go",
    "code_content": "package inventory\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n)\n\n// StockManager handles updating product stock.\ntype StockManager struct {\n\tdb *sql.DB\n}\n\n// NewStockManager creates a new StockManager.\nfunc NewStockManager(db *sql.DB) *StockManager {\n\treturn &StockManager{db: db}\n}\n\n// DecrementStock decreases the stock of a product within a transaction.\nfunc (sm *StockManager) DecrementStock(ctx context.Context, productID int64, quantity int) error {\n\ttx, err := sm.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"begin transaction failed: %w\", err)\n\t}\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\ttx.Rollback()\n\t\t\tlog.Printf(\"panic recovered: %v\", r)\n\t\t} else if err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}()\n\n\t_, err = tx.ExecContext(ctx, \"UPDATE products SET stock = stock - ? WHERE id = ?\", quantity, productID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"update failed: %w\", err)\n\t}\n\tif quantity > 50 {\n\t\terr = errors.New(\"large quantity update, consider approval\")\n\t\treturn err\n\t}\n\terr = tx.Commit()\n\treturn err\n}",
    "source_schema": "CREATE TABLE products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255),\n    stock INT\n);",
    "target_schema": "CREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(255),\n    stock INT64,\n) PRIMARY KEY (id);",
    "ground_truth": ["36"],
    "description": "Go code managing a stock decrement within a transaction, including error handling and a deferred rollback. Migration concerns involve the transaction management (`BeginTx`, `ExecContext`, `Commit`, `Rollback`) and ensuring Spanner's transaction retry mechanisms are considered."
  },
  {
    "filePath": "pkg/customer/aggregator.go",
    "code_content": "package customer\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n)\n\n// Aggregator gets aggregate customer data.\ntype Aggregator struct {\n\tdb *sql.DB\n}\n\n// NewAggregator creates a new Aggregator.\nfunc NewAggregator(db *sql.DB) *Aggregator {\n\treturn &Aggregator{db: db}\n}\n\n// UniqueNames fetches all unique customer names.\nfunc (a *Aggregator) UniqueNames(ctx context.Context) (string, error) {\n\tquery := \"SELECT DISTINCT name FROM customers\"\n\trows, err := a.db.QueryContext(ctx, query)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\tdefer rows.Close()\n\tvar namesstring\n\tfor rows.Next() {\n\t\tvar name string\n\t\tif err := rows.Scan(&name); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"scan failed: %w\", err)\n\t\t}\n\t\tnames = append(names, name)\n\t}\n\treturn names, nil\n}",
    "source_schema": "CREATE TABLE customers (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255)\n);",
    "target_schema": "CREATE TABLE customers (\n    id INT64 NOT NULL,\n    name STRING(255),\n) PRIMARY KEY (id);",
    "ground_truth": [],
    "description": "Go code using SELECT DISTINCT with QueryContext. The SQL is standard, making the `database/sql` call the primary migration focus."
  },
  {
    "filePath": "internal/product/factory.go",
    "code_content": "package factory\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"example.com/project/internal/model\"\n\t\"fmt\"\n)\n\n// Factory creates products and returns their IDs.\ntype Factory struct {\n\tdb *sql.DB\n}\n\n// NewFactory creates a new Factory.\nfunc NewFactory(db *sql.DB) *Factory {\n\treturn &Factory{db: db}\n}\n\n// CreateAndReturnID inserts a product and attempts to return the last insert ID.\nfunc (f *Factory) CreateAndReturnID(ctx context.Context, product *model.Product) (int64, error) {\n\tvar newID int64\n\tquery := \"INSERT INTO products (name, price) VALUES (?, ?) RETURNING id\"\n\terr := f.db.QueryRowContext(ctx, query, product.Name, product.Price).Scan(&newID)\n\tif err != nil {\n\t\t// MySQL doesn't support RETURNING, fallback to LastInsertId\n\t\tresult, err2 := f.db.ExecContext(ctx, \"INSERT INTO products (name, price) VALUES (?, ?)\", product.Name, product.Price)\n\t\tif err2 != nil {\n\t\t\treturn 0, fmt.Errorf(\"insert failed: %w\", err2)\n\t\t}\n\t\treturn result.LastInsertId()\n\t}\n\treturn newID, nil\n}",
    "source_schema": "CREATE TABLE products (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL(10,2) NOT NULL\n);",
    "target_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind='bit_reversed_positive');\n CREATE TABLE products (\n    id INT64 DEFAULT (NEXT VALUE FOR ProductIdSequence),\n    name STRING(255) NOT NULL,\n    price FLOAT64 NOT NULL,\n) PRIMARY KEY (id);",
    "ground_truth": ["23"],
    "description": "Go code attempting to use a RETURNING clause (common in PostgreSQL, not MySQL) and falling back to LastInsertId. Migration needs to handle Spanner's lack of direct RETURNING support for INSERTs (you'd typically generate the ID beforehand or use a sequence)."
  },
  {
    "filePath": "pkg/search/article_search.go",
    "code_content": "package search\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"example.com/project/pkg/model\"\n\t\"fmt\"\n)\n\n// ArticleSearcher finds articles using full-text search.\ntype ArticleSearcher struct {\n\tdb *sql.DB\n}\n\n// NewArticleSearcher creates a new ArticleSearcher.\nfunc NewArticleSearcher(db *sql.DB) *ArticleSearcher {\n\treturn &ArticleSearcher{db: db}\n}\n\n// Search performs a full-text search on articles.\nfunc (as *ArticleSearcher) Search(ctx context.Context, query string) (*model.Article, error) {\n\tsqlQuery := `SELECT id, title, body\n\t\t\tFROM articles\n\t\t\tWHERE MATCH (title, body) AGAINST (? IN NATURAL LANGUAGE MODE)`\n\trows, err := as.db.QueryContext(ctx, sqlQuery, query)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"query failed: %w\", err)\n\t}\n\tdefer rows.Close()\n\tvar articles*model.Article\n\tfor rows.Next() {\n\t\tvar article model.Article\n\t\tif err := rows.Scan(&article.ID, &article.Title, &article.Body); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"scan failed: %w\", err)\n\t\t}\n\t\tarticles = append(articles, article)\n\t}\n\treturn articles, nil\n}",
    "source_schema": "CREATE TABLE articles (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    body TEXT,\n    FULLTEXT (title, body)\n);",
    "target_schema": "-- Spanner does not support FULLTEXT indexes. Consider using a separate search service or text matching in application.\nCREATE TABLE articles (\n    id INT64 NOT NULL,\n    title STRING(255) NOT NULL,\n    body STRING(MAX),\n) PRIMARY KEY (id);",
    "ground_truth": ["22", "23", "24"],
    "description": "Go code using MySQL's MATCH ... AGAINST for full-text search with QueryContext. Spanner lacks native full-text indexing, so this requires integration with an external search service or application-level text matching."
  },
  {
    "filePath": "pkg/user/deleter.go",
    "code_content": "package user\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"log\"\n)\n\n// Deleter handles deleting users and their associated data.\ntype Deleter struct {\n\tdb *sql.DB\n}\n\n// NewDeleter creates a new Deleter.\nfunc NewDeleter(db *sql.DB) *Deleter {\n\treturn &Deleter{db: db}\n}\n\n// DeleteUserAndPosts deletes a user and their posts (assuming ON DELETE CASCADE).\nfunc (d *Deleter) DeleteUserAndPosts(ctx context.Context, userID int64) error {\n\ttx, err := d.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"begin transaction failed: %w\", err)\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tlog.Printf(\"Transaction rolled back: %v\", err)\n\t\t} else {\n\t\t\ttx.Commit()\n\t\t\tlog.Println(\"Transaction committed.\")\n\t\t}\n\t}()\n\n\t// In MySQL with ON DELETE CASCADE, deleting the user might be enough\n\t_, err = tx.ExecContext(ctx, \"DELETE FROM users WHERE id = ?\", userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete user failed: %w\", err)\n\t}\n\n\t// For Spanner, we might need to explicitly delete posts if not using INTERLEAVE ON DELETE CASCADE\n\t_, err = tx.ExecContext(ctx, \"DELETE FROM posts WHERE user_id = ?\", userID)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"delete posts failed: %w\", err)\n\t}\n\n\treturn nil\n}",
    "source_schema": "CREATE TABLE users (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(255)\n);\nCREATE TABLE posts (\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\n    user_id BIGINT,\n    title VARCHAR(255),\n    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);",
    "target_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(255),\n) PRIMARY KEY (id);\nCREATE TABLE posts (\n    id INT64 NOT NULL,\n    user_id INT64 NOT NULL,\n    title STRING(255),\n    CONSTRAINT FK_UserPosts FOREIGN KEY (user_id) REFERENCES users(id),\n) PRIMARY KEY (id), INTERLEAVE IN PARENT users ON DELETE CASCADE;",
    "ground_truth": ["42", "43"],
    "description": "Go code demonstrating deletion within a transaction, implicitly relying on ON DELETE CASCADE in MySQL. For Spanner, explicit deletion or the use of INTERLEAVE with ON DELETE CASCADE is necessary. Transaction management calls are also relevant."
  }
]