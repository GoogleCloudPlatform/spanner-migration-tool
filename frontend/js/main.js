/**
 * Function to trigger click event while file uploading
 *
 * @return {null}
 */
const uploadFileHandler = (e) => {
  e.preventDefault();
  jQuery("#upload:hidden").trigger('click');
}

/**
 * Function to update selected file name and to read the json content of selected file
 *
 * @return {null}
 */
const filenameChangeHandler = () => {
  let importSchemaObj;
  let fileName = jQuery('#upload')[0].files[0].name;
  jQuery("#upload_link").text(fileName);

  let reader = new FileReader();
  reader.onload = function (event) {
    try {
      importSchemaObj = JSON.parse(event.target.result);
    }
    catch (e) {
      showSnackbar(e, ' redBg');
      return;
    }
    jQuery('#importButton').removeAttr('disabled');
    localStorage.setItem('conversionReportContent', JSON.stringify(importSchemaObj));
    localStorage.setItem('importFileName', fileName);
    localStorage.setItem('importFilePath', 'frontend/');
  }
  reader.readAsText(event.target.files[0]);
}

/**
 * Function to handle click event on edit spanner schema button of table
 *
 * @param {HTMLElement} event click event
 * @param {array} spPlaceholder array to store number of selected constraints in spanner constraint cell
 * @param {array} tablePkArray array to store primary keys of a table
 * @param {number} pkSeqId sequence number of primary key
 * @param {array} columnsNotNullConstraint array to store not null constraint value for all columns of a particular table
 * @param {array} tableOriginalColNames array to store original column names of a particular table
 * @param {array} keyColumnMap array to store primary key and column as a map of a particular table
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @param {array} pkSpArray
 * @return {null}
 */
const editAndSaveButtonHandler = (event, spPlaceholder, tablePkArray, pkSeqId, columnsNotNullConstraint, tableOriginalColNames, keyColumnMap, notPrimaryArray, pkSpArray) => {
  if (event[0].innerText === "Edit Spanner Schema") {
    editSpannerHandler(event, tablePkArray, pkSeqId, columnsNotNullConstraint, tableOriginalColNames, keyColumnMap, notPrimaryArray);
  }
  else if (event[0].innerText === "Save Changes") {
    saveSpannerChanges(event, spPlaceholder, notPrimaryArray, pkSpArray);
  }
}

/**
 * Function to handle spanner table editing
 *
 * @param {event} event event generated by clicking edit spanner button
 * @param {array} tablePkArray array to store primary keys of a table
 * @param {number} pkSeqId sequence number of primary key
 * @param {array} columnsNotNullConstraint array to store not null constraint value for all columns of a particular table
 * @param {array} tableOriginalColNames array to store original column names of a particular table
 * @param {array} keyColumnMap array to store primary key and column as a map of a particular table
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @return {null}
 */
const editSpannerHandler = (event, tablePkArray, pkSeqId, columnsNotNullConstraint, tableOriginalColNames, keyColumnMap, notPrimaryArray) => {
  let uncheckCount = [];
  let tableNumber = parseInt(event.attr('id').match(/\d+/), 10);
  let tableId = '#src-sp-table' + tableNumber + ' tr';
  let tableColumnNumber = 0;
  let tableCheckboxGroup = '.chckClass_' + tableNumber;
  let $selectAll, $selectEachRow;
  if (event.html() === 'Edit Spanner Schema') {
    jQuery(event[0]).removeAttr('data-toggle');
  }
  event.html("Save Changes");
  uncheckCount[tableNumber] = 0;

  jQuery(tableId).each(function (index) {
    if (index === 1) {
      $selectAll = jQuery(this).find('.bmd-form-group.is-filled.template');
      $selectAll.removeClass('template');
      $selectAll.find('input').attr('id', 'chckAll_' + tableNumber);
    }
    var checkAllTableNumber = jQuery('#chckAll_' + tableNumber);
    var checkClassTableNumber = jQuery('.chckClass_' + tableNumber);
    checkAllTableNumber.prop('checked', true);
    checkAllTableNumber.click(function () {
      tableNumber = parseInt(jQuery(this).attr('id').match(/\d+/), 10);
      checkClassTableNumber = jQuery('.chckClass_' + tableNumber);
      switch (jQuery(this).is(':checked')) {
        case true:
          checkClassTableNumber.prop('checked', true);
          uncheckCount[tableNumber] = 0;
          break;
        case false:
          checkClassTableNumber.prop('checked', false);
          uncheckCount[tableNumber] = Object.keys(schemaConversionObj.ToSpanner[schemaConversionObj.SpSchema[srcTableName[tableNumber]].Name].Cols).length;
          break;
      }
    });

    if (index > 2) {
      $selectEachRow = jQuery(this).find('.bmd-form-group.is-filled.eachRowChckBox.template');
      $selectEachRow.removeClass('template');
      $selectEachRow.find('input').attr('id', 'chckBox_' + tableColumnNumber);
      $selectEachRow.find('input').addClass('chckClass_' + tableNumber);
      jQuery(tableCheckboxGroup).prop('checked', true);
      let spannerCellsList = document.getElementsByClassName('spannerTabCell' + tableNumber + tableColumnNumber);
      if (spannerCellsList) {
        editSpannerColumnName(tableNumber, tableColumnNumber, tableId, tablePkArray, pkSeqId, tableOriginalColNames, keyColumnMap, notPrimaryArray);
        editSpannerDataType(spannerCellsList[1], tableNumber, tableColumnNumber);
        editSpannerConstraint(spannerCellsList[2], tableNumber, tableColumnNumber, columnsNotNullConstraint);
      }
      tableColumnNumber++;
    }
  });
  checkClassTableNumber = jQuery('.chckClass_' + tableNumber);
  checkClassTableNumber.click(function () {
    tableNumber = parseInt(jQuery(this).closest("table").attr('id').match(/\d+/), 10);
    tableColumnNumber = parseInt(jQuery(this).attr('id').match(/\d+/), 10);
    checkAllTableNumber = jQuery('#chckAll_' + tableNumber);
    if (jQuery(this).is(":checked")) {
      uncheckCount[tableNumber] = uncheckCount[tableNumber] - 1;
      if (uncheckCount[tableNumber] === 0) {
        checkAllTableNumber.prop('checked', true);
      }
    }
    else {
      uncheckCount[tableNumber] = uncheckCount[tableNumber] + 1;
      checkAllTableNumber.prop('checked', false);
    }
  });
}

/**
 * Function to edit column name for spanner table
 *
 * @param {number} tableNumber
 * @param {number} tableColumnNumber
 * @param {string} tableId
 * @param {array} tablePkArray array to store primary keys of a table
 * @param {number} pkSeqId sequence number of primary key
 * @param {array} tableOriginalColNames array to store original column names of a particular table
 * @param {array} keyColumnMap array to store primary key and column as a map of a particular table
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @return {null}
 */
const editSpannerColumnName = (tableNumber, tableColumnNumber, tableId, tablePkArray, pkSeqId, tableOriginalColNames, keyColumnMap, notPrimaryArray) => {
  let columnNameVal = document.getElementById('columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber).innerHTML;
  let currSeqId = '';
  let pkArrayLength = tablePkArray.length;
  tableOriginalColNames.push(columnNameVal);
  for (var x = 0; x < pkArrayLength; x++) {
    if (tablePkArray[x].Col === columnNameVal.trim()) {
      currSeqId = tablePkArray[x].seqId;
    }
  }
  let $editColumnName = jQuery('#editColumnName' + tableNumber + tableColumnNumber).removeClass('template');
  $editColumnName.find('.column.left.keyMargin.keyClick').attr('id', 'keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber);
  $editColumnName.find('.column.right.form-group > input').attr('id', 'columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber);
  $editColumnName.find('.column.right.form-group > input').attr('value', columnNameVal);
  jQuery('#saveColumnName' + tableNumber + tableColumnNumber).addClass('template');
  if (notPrimaryArray[tableColumnNumber] === true) {

    $editColumnName.find('.column.left.keyMargin.keyClick > img').attr('src', './Icons/Icons/ic_vpn_key_24px-inactive.svg');
    $editColumnName.find('.column.left.keyMargin.keyClick').addClass('keyNotActive');
    $editColumnName.find('.column.left.keyMargin.keyClick').removeClass('keyActive');
  }
  else {
    $editColumnName.find('.column.left.keyMargin.keyClick > img').attr('src', './Icons/Icons/ic_vpn_key_24px.svg');
    $editColumnName.find('.column.left.keyMargin.keyClick > sub').html(currSeqId);
    $editColumnName.find('.column.left.keyMargin.keyClick').addClass('keyActive');
    $editColumnName.find('.column.left.keyMargin.keyClick').removeClass('keyNotActive');
  }
  jQuery('#keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).click(function () {
    jQuery(this).toggleClass('keyActive keyNotActive');
    let keyId = jQuery(this).attr('id');
    let keyColumnMapLength = keyColumnMap.length;
    for (var z = 0; z < keyColumnMapLength; z++) {
      if (keyId === keyColumnMap[z].keyIconId) {
        columnName = keyColumnMap[z].columnName;
      }
    }
    if (document.getElementById(keyId).classList.contains('keyActive')) {
      getNewSeqNumForPrimaryKey(keyId, tableNumber, tableColumnNumber, tablePkArray, pkSeqId);
    }
    else {
      removePrimaryKeyFromSeq(tableNumber, tableId, tablePkArray, tableOriginalColNames, notPrimaryArray);
    }
  });
}

/**
 * Function to get new seq number for primary key
 *
 * @param {html id} keyId
 * @param {number} tableNumber specifies table number in json object
 * @param {number} tableColumnNumber Specifies table column number
 * @param {array} tablePkArray array to store primary keys of a table
 * @param {number} pkSeqId sequence number of primary key
 * @return {null}
 */
const getNewSeqNumForPrimaryKey = (keyId, tableNumber, tableColumnNumber, tablePkArray, pkSeqId) => {
  let maxSeqId = 0;
  let pkArrayLength = tablePkArray.length;
  let pkFoundFlag = false;
  for (var z = 0; z < pkArrayLength; z++) {
    if (tablePkArray[z].seqId > maxSeqId) {
      maxSeqId = tablePkArray[z].seqId;
    }
  }
  maxSeqId = maxSeqId + 1;
  pkSeqId = maxSeqId;
  for (var z = 0; z < pkArrayLength; z++) {
    if (columnName != tablePkArray[z].Col) {
      pkFoundFlag = false;
    }
    else {
      pkFoundFlag = true;
      break;
    }
  }
  if (pkFoundFlag === false) {
    tablePkArray.push({ 'Col': columnName, 'seqId': pkSeqId });
  }
  schemaConversionObj.SpSchema[srcTableName[tableNumber]].Pks = tablePkArray;
  jQuery('#editColumnName' + tableNumber + tableColumnNumber).find('sub').html(pkSeqId);
  jQuery('#editColumnName' + tableNumber + tableColumnNumber).find('img').attr('src', './Icons/Icons/ic_vpn_key_24px.svg');
}

/**
 * Function to remove primary key from existing sequence
 *
 * @param {number} tableNumber
 * @param {string} tableId
 * @param {array} tablePkArray array to store primary keys of a table
 * @param {array} tableOriginalColNames array to store original column names of a particular table
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @return {null}
 */
const removePrimaryKeyFromSeq = (tableNumber, tableId, tablePkArray, tableOriginalColNames, notPrimaryArray) => {
  let pkArrayLength = tablePkArray.length;
  let currSeqId;
  let tableColumnNumber = 0;
  for (var z = 0; z < pkArrayLength; z++) {
    if (columnName === tablePkArray[z].Col) {
      tablePkArray.splice(z, 1);
      break;
    }
  }
  pkArrayLength = tablePkArray.length;
  for (var x = z; x < pkArrayLength; x++) {
    tablePkArray[x].seqId = tablePkArray[x].seqId - 1;
  }
  schemaConversionObj.SpSchema[srcTableName[tableNumber]].Pks = tablePkArray;
  jQuery(tableId).each(function (index) {
    if (index > 2) {
      notPrimaryArray[tableColumnNumber] = true;
      currSeqId = '';
      for (var x = 0; x < pkArrayLength; x++) {
        if (tablePkArray[x].Col === tableOriginalColNames[tableColumnNumber].trim()) {
          currSeqId = tablePkArray[x].seqId;
          notPrimaryArray[tableColumnNumber] = false;
        }
      }
      if (notPrimaryArray[tableColumnNumber] === true) {
        jQuery('#keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).find('sub').html('');
        jQuery('#keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).find('img').attr('src', './Icons/Icons/ic_vpn_key_24px-inactive.svg');
      }
      else {
        jQuery('#keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).find('sub').html(currSeqId);
        jQuery('#keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).find('img').attr('src', './Icons/Icons/ic_vpn_key_24px.svg');
      }
      tableColumnNumber++;
    }
  });
}

/**
 * Function to edit data type for spanner table
 *
 * @param {html Element} editColumn
 * @param {number} tableNumber
 * @param {number} tableColumnNumber
 * @return {null}
 */
const editSpannerDataType = (editColumn, tableNumber, tableColumnNumber) => {
  let spannerCellValue = editColumn.innerHTML;
  let srcCellValue, $dataTypeOption;
  let srcCellValueEle = document.getElementById('srcDataType' + tableNumber + tableColumnNumber);
  let dataTypeArray = null;
  let globalDataTypes = JSON.parse(localStorage.getItem('globalDataTypeList'));
  let globalDataTypesLength = Object.keys(globalDataTypes).length;
  let $editDataType = jQuery('#editDataType' + tableNumber + tableColumnNumber).removeClass('template');
  if (srcCellValueEle) {
    srcCellValue = srcCellValueEle.innerHTML;
  }
  for (var a = 0; a < globalDataTypesLength; a++) {
    if (srcCellValue.toLowerCase() === (Object.keys(globalDataTypes)[a]).toLowerCase()) {
      dataTypeArray = globalDataTypes[Object.keys(globalDataTypes)[a]];
      break;
    }
  }
  $editDataType.find('select').attr('id', 'dataType' + tableNumber + tableColumnNumber + tableColumnNumber);
  jQuery('#saveDataType' + tableNumber + tableColumnNumber).addClass('template');
  if (dataTypeArray !== null) {
    let dataTypeArrayLength = dataTypeArray.length;
    for (var a = 0; a < dataTypeArrayLength; a++) {
      $dataTypeOption = $editDataType.find('.dataTypeOption.template').clone().removeClass('template');
      if (spannerCellValue == dataTypeArray[a].T) {
        $dataTypeOption.attr('value', dataTypeArray[a].T);
        $dataTypeOption.html(dataTypeArray[a].T);
        $dataTypeOption.attr('selected', 'selected');
      }
      else {
        $dataTypeOption.attr('value', dataTypeArray[a].T);
        $dataTypeOption.html(dataTypeArray[a].T);
      }
      $dataTypeOption.appendTo($editDataType.find('select'));
    }
  }
  else {
    $dataTypeOption = $editDataType.find('.dataTypeOption.template').clone().removeClass('template');
    $dataTypeOption.attr('value', spannerCellValue);
    $dataTypeOption.html(spannerCellValue);
    $dataTypeOption.appendTo($editDataType.find('select'));
  }
  jQuery($editDataType.find('select')).find("option").eq(0).remove();
}

/**
 * Function to edit constraint for spanner table
 *
 * @param {html Element} editColumn
 * @param {number} tableNumber
 * @param {number} tableColumnNumber
 * @param {array} columnsNotNullConstraint array to store not null constraint value for all columns of a particular table
 * @return {null}
 */
const editSpannerConstraint = (editColumn, tableNumber, tableColumnNumber, columnsNotNullConstraint) => {
  let notNullFound = '';
  let constraintId = 'spConstraint' + tableNumber + tableColumnNumber;
  if (columnsNotNullConstraint[tableColumnNumber] === true) {
    notNullFound = "<option class='active' selected>Not Null</option>";
  }
  else if (columnsNotNullConstraint[tableColumnNumber] === false) {
    notNullFound = "<option>Not Null</option>";
  }
  constraintHtml = "<select id=" + constraintId + " multiple size='0' class='form-control spanner-input tableSelect' >"
    + notNullFound
    + "</select>";
  editColumn.innerHTML = constraintHtml;
  new vanillaSelectBox("#spConstraint" + tableNumber + tableColumnNumber, {
    placeHolder: "Select Constraints",
    maxWidth: 500,
    maxHeight: 300
  });
  jQuery('#spConstraint' + tableNumber + tableColumnNumber).on('change', function () {
    let idNum = parseInt(jQuery(this).attr('id').match(/\d+/g), 10);
    let constraints = document.getElementById(constraintId);
    constraintId = jQuery(this).attr('id');
    notNullConstraint[idNum] = '';
    if (constraints) {
      let constraintsLength = constraints.length;
      for (var c = 0; c < constraintsLength; c++) {
        if (constraints.options[c].selected) {
          notNullConstraint[idNum] = 'Not Null';
        }
      }
    }
  });
}

/**
 * Function to save changes of spanner table
 *
 * @param {event} event event generated by clicking edit spanner button
 * @param {array} spPlaceholder array to store number of selected constraints in spanner constraint cell
 * @param {array} tableOriginalColNames array to store original column names of a particular table
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @param {array} pkSpArray
 * @return {null}
 */
const saveSpannerChanges = async (event, spPlaceholder, notPrimaryArray, pkSpArray) => {
  if (event.html() === 'Save Changes') {
    showSnackbar('changes saved successfully !!', ' greenBg');
  }
  event.html("Edit Spanner Schema");

  let tableNumber = parseInt(event.attr('id').match(/\d+/), 10);
  let tableId = '#src-sp-table' + tableNumber + ' tr';
  updatedColsData = {
    'UpdateCols': {
    }
  }
  jQuery(tableId).each(function (index) {
    if (index > 2) {
      tableName = srcTableName[tableNumber];
      let newColumnName;
      let tableColumnNumber = parseInt(jQuery(this).find('.srcColumn').attr('id').match(/\d+/), 10);
      let srcColumnName = jQuery(this).find('.srcColumn').html().trim();
      let spannerCellsList = document.getElementsByClassName('spannerTabCell' + tableNumber + tableColumnNumber);
      let newColumnNameEle = document.getElementById('columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber);
      if (newColumnNameEle) {
        newColumnName = newColumnNameEle.value;
      }
      let originalColumnName = schemaConversionObj.ToSpanner[srcTableName[tableNumber]].Cols[srcColumnName];
      updatedColsData.UpdateCols[originalColumnName] = {};
      updatedColsData.UpdateCols[originalColumnName]['Removed'] = false;
      if (newColumnName === originalColumnName) {
        updatedColsData.UpdateCols[originalColumnName]['Rename'] = '';
      }
      else {
        updatedColsData.UpdateCols[originalColumnName]['Rename'] = newColumnName;
      }
      updatedColsData.UpdateCols[originalColumnName]['NotNull'] = '';
      updatedColsData.UpdateCols[originalColumnName]['PK'] = '';
      savePrimaryKeySeq(tableNumber, tableColumnNumber, originalColumnName, newColumnName, notPrimaryArray, pkSpArray);
      updatedColsData.UpdateCols[originalColumnName]['ToType'] = document.getElementById('dataType' + tableNumber + tableColumnNumber + tableColumnNumber).value;
      saveSpannerConstraints(tableNumber, tableColumnNumber, originalColumnName);
      if (!(jQuery(this).find("input[type=checkbox]").is(":checked"))) {
        updatedColsData.UpdateCols[originalColumnName]['Removed'] = true;
      }
      new vanillaSelectBox('#spConstraint' + tableNumber + tableColumnNumber, {
        placeHolder: spPlaceholder[tableNumber][tableColumnNumber] + " constraints selected",
        maxWidth: 500,
        maxHeight: 300
      });
    }
  })

  jQuery(tableId).each(function () {
    jQuery(this).find('.src-tab-cell .bmd-form-group').remove();
  });
  tooltipHandler();
  showSpinner();
  await fetch('/typemap/table?table=' + tableName, {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(updatedColsData)
  })
    .then(function (res) {
      if (res.ok) {
        res.json().then(async function (response) {
          localStorage.setItem('conversionReportContent', JSON.stringify(response));
          await ddlSummaryAndConversionApiCall();
          await getInterleaveInfo();
          const { component = ErrorComponent } = findComponentByPath(location.hash.slice(1).toLowerCase() || paths.defaultPath, routes) || {};
          component.render();
        });
      }
      else {
        return Promise.reject(res);
      }
    })
    .catch(function (err) {
      showSnackbar(err, ' redBg');
    });
}

/**
 * Function to save column name for spanner table
 *
 * @param {number} tableNumber table number
 * @param {number} tableColumnNumber table column number
 * @param {string} originalColumnName 
 * @param {string} newColumnName
 * @param {array} notPrimaryArray array to store whether column of a particular table is PK or not
 * @param {array} pkSpArray
 * 
 * @return {null}
 */
const savePrimaryKeySeq = (tableNumber, tableColumnNumber, originalColumnName, newColumnName, notPrimaryArray, pkSpArray) => {
  let currentPks = schemaConversionObj.SpSchema[srcTableName[tableNumber]].Pks;
  let pksSpLength = pkSpArray.length;
  let currentPksLength = currentPks.length;
  let foundOriginally;
  let currSeqId = '';
  let $saveColumnName = jQuery('#saveColumnName' + tableNumber + tableColumnNumber).removeClass('template');
  jQuery('#editColumnName' + tableNumber + tableColumnNumber).addClass('template');
  if (document.getElementById('keyIcon' + tableNumber + tableColumnNumber + tableColumnNumber).classList.contains('keyActive')) {
    // checking if this key is newly added or removed
    foundOriginally = false;
    for (var z = 0; z < pksSpLength; z++) {
      if (originalColumnName === pkSpArray[z].Col) {
        foundOriginally = true;
        break;
      }
    }
    if (foundOriginally === false) {
      updatedColsData.UpdateCols[originalColumnName]['PK'] = 'ADDED';
    }

    for (var z = 0; z < currentPksLength; z++) {
      if (currentPks[z].Col === newColumnName) {
        currSeqId = currentPks[z].seqId;
      }
    }

    $saveColumnName.find('.column.left.spannerPkSpan').attr('data-toggle', 'tooltip');
    $saveColumnName.find('.column.left.spannerPkSpan').attr('data-placement', 'bottom');
    $saveColumnName.find('.column.left.spannerPkSpan').attr('title', 'primary key : ' + document.getElementById('columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber).value);
    $saveColumnName.find('.column.left.spannerPkSpan').css('cursor', 'pointer');
    $saveColumnName.find('sub').html(currSeqId);
    $saveColumnName.find('.column.right.spannerColNameSpan').attr('data-toggle', 'tooltip');
    $saveColumnName.find('.column.right.spannerColNameSpan').attr('data-placement', 'bottom');
    $saveColumnName.find('.column.right.spannerColNameSpan').attr('title', 'primary key : ' + document.getElementById('columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber).value);
    $saveColumnName.find('.column.right.spannerColNameSpan').attr('id', 'columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber);
    $saveColumnName.find('.column.right.spannerColNameSpan').css('cursor', 'pointer');
    $saveColumnName.find('.column.right.spannerColNameSpan').html(document.getElementById('columnNameText' + tableNumber + tableColumnNumber + tableColumnNumber).value);
    notPrimaryArray[tableColumnNumber] = false;
  }
  else {

    // checking if this key is newly added or removed
    foundOriginally = false;
    for (var z = 0; z < pksSpLength; z++) {
      if (originalColumnName === pkSpArray[z].Col) {
        foundOriginally = true;
        updatedColsData.UpdateCols[originalColumnName]['PK'] = 'REMOVED';
        break;
      }
    }
  }
  notPrimaryArray[tableColumnNumber] = true;
}

/**
 * Function to save constraints for spanner table
 *
 * @param {number} tableNumber table number
 * @param {number} tableColumnNumber table column number
 * @param {string} originalColumnName
 * 
 * @return {null}
 */
const saveSpannerConstraints = (tableNumber, tableColumnNumber, originalColumnName) => {
  let constraintIndex = String(tableNumber) + String(tableColumnNumber);
  constraintIndex = parseInt(constraintIndex);

  if (notNullConstraint[constraintIndex] === 'Not Null') {
    updatedColsData.UpdateCols[originalColumnName]['NotNull'] = 'ADDED';
  }
  else if (notNullConstraint[constraintIndex] === '') {
    updatedColsData.UpdateCols[originalColumnName]['NotNull'] = 'REMOVED';
  }
}

/**
 * Function to call database connection api.
 *
 * @param {string} dbType Type of db like mysql, postgres, etc
 * @param {string} dbHost Database host
 * @param {number} dbPort Database port number
 * @param {string} dbUser Database user name
 * @param {string} dbName Database name
 * @param {string} dbPassword Database password
 * @return {null}
 */
const onconnect = (dbType, dbHost, dbPort, dbUser, dbName, dbPassword) => {
  let sourceTableFlag = '';
  showSpinner();
  fetch('/connect', {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      "Driver": dbType,
      "Database": dbName,
      "Password": dbPassword,
      "User": dbUser,
      "Port": dbPort,
      "Host": dbHost
    })
  })
    .then(function (res) {
      hideSpinner();
      if (res.ok) {
        if (dbType === 'mysql')
          sourceTableFlag = 'MySQL';
        else if (dbType === 'postgres')
          sourceTableFlag = 'Postgres';
        localStorage.setItem('sourceDbName', sourceTableFlag);
        jQuery('#connectToDbModal').modal('hide');
        jQuery('#connectModalSuccess').modal();

      }
      else {
        res.text().then(function () {
          jQuery('#connectToDbModal').modal('hide');
          jQuery('#connectModalFailure').modal();
        });
      }
    })
    .catch(function (err) {
      showSnackbar(err, ' redBg');
    })
}

/**
 * Function to render edit schema screen from connect to DB mode
 *
 * @return {null}
 */
const showSchemaAssessment = async () => {
  let reportDataResp, reportData, sourceTableFlag;
  showSpinner();
  reportData = await fetch('/convert/infoschema')
    .then(function (response) {
      if (response.ok) {
        return response;
      }
      else {
        return Promise.reject(response);
      }
    })
    .catch(function (err) {
      showSnackbar(err, ' redBg');
    });
  reportDataResp = await reportData.json();
  localStorage.setItem('conversionReportContent', JSON.stringify(reportDataResp));
  await ddlSummaryAndConversionApiCall();
  await getInterleaveInfo();
  window.location.href = '#/schema-report-connect-to-db';
  sourceTableFlag = localStorage.getItem('sourceDbName');
  jQuery('#connectModalSuccess').modal("hide");
  sessionRetrieval(sourceTableFlag);
}

/**
 * Function to store db dump values in local storage
 *
 * @param {string} dbType selected db like mysql, postgres, etc
 * @param {string} filePath path entered for the dump file
 * @return {null}
 */
const storeDumpFileValues = (dbType, filePath) => {
  let sourceTableFlag = '';
  if (dbType === 'mysql') {
    localStorage.setItem('globalDbType', dbType + 'dump');
    sourceTableFlag = 'MySQL';
    localStorage.setItem('sourceDbName', sourceTableFlag);
  }
  else if (dbType === 'postgres') {
    localStorage.setItem('globalDbType', 'pg_dump');
    sourceTableFlag = 'Postgres';
    localStorage.setItem('sourceDbName', sourceTableFlag);
  }
  localStorage.setItem('globalDumpFilePath', filePath);
  onLoadDatabase(localStorage.getItem('globalDbType'), localStorage.getItem('globalDumpFilePath'));
}

/**
 * Function to call /convert/dump api to get con json structure
 *
 * @param {string} dbType selected db like mysql, postgres, etc
 * @param {string} dumpFilePath path entered for the dump file
 * @return {null}
 */
const onLoadDatabase = async (dbType, dumpFilePath) => {
  let reportData, sourceTableFlag, reportDataResp;
  showSpinner();
  reportData = await fetch('/convert/dump', {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      "Driver": dbType,
      "Path": dumpFilePath
    })
  });
  requestCode = await reportData.status;
  reportDataResp = await reportData.text();

  if (requestCode != 200) {
    hideSpinner();
    showSnackbar(reportDataResp, ' redBg');
    return;
  }
  else {
    jQuery('#loadDatabaseDumpModal').modal('hide');
    reportDataResp = JSON.parse(reportDataResp);
    localStorage.setItem('conversionReportContent', JSON.stringify(reportDataResp));
  }
  await ddlSummaryAndConversionApiCall();
  await getInterleaveInfo();
  window.location.href = '#/schema-report-load-db-dump';
  sourceTableFlag = localStorage.getItem('sourceDbName');
  sessionRetrieval(sourceTableFlag);
}

/**
 * Function to import schema and populate summary, ddl, conversion report panels
 *
 * @return {null}
 */
const onImport = async () => {
  let driver = '';
  let srcDb = localStorage.getItem('sourceDbName');
  if (srcDb === 'MySQL') {
    driver = 'mysqldump';
  }
  else if (srcDb === 'Postgres') {
    driver = 'pg_dump';
  }
  let path = localStorage.getItem('importFilePath');
  let fileName = localStorage.getItem('importFileName');
  await fetch('/session/resume', {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      "driver": driver,
      "path": path,
      "fileName": fileName
    })
  })
  .then(function (res) {
    console.log(res);
  });
  await ddlSummaryAndConversionApiCall();
  await getInterleaveInfo();
  jQuery('#importSchemaModal').modal('hide');
  const { component = ErrorComponent } = findComponentByPath(paths.importDb, routes) || {};
  component.render();
}

/**
 * Function to make ddl, summary and conversion api calls
 *
 * @return {null}
 */
const ddlSummaryAndConversionApiCall = async () => {
  let conversionRateResp, ddlDataResp, summaryDataResp;
  fetch('/ddl')
    .then(async function (response) {
      if (response.ok) {
        ddlDataResp = await response.json();
        localStorage.setItem('ddlStatementsContent', JSON.stringify(ddlDataResp));
        fetch('/summary')
          .then(async function (response) {
            if (response.ok) {
              summaryDataResp = await response.json();
              localStorage.setItem('summaryReportContent', JSON.stringify(summaryDataResp));
              fetch('/conversion')
                .then(async function (response) {
                  if (response.ok) {
                    conversionRateResp = await response.json();
                    localStorage.setItem('tableBorderColor', JSON.stringify(conversionRateResp));
                  }
                  else {
                    return Promise.reject(response);
                  }
                })
                .catch(function (err) {
                  showSnackbar(err, ' redBg');
                });
            } 
            else {
              return Promise.reject(response);
            }
          })
          .catch(function (err) {
            showSnackbar(err, ' redBg');
          });
      }
      else {
        return Promise.reject(response);
      }
    })
    .catch(function (err) {
      showSnackbar(err, ' redBg');
    });
}

/**
 * Function to make an api call to get download file paths
 *
 * @return {null}
 */
const getReportAndSummaryFilePaths = () => {
  fetch('/filepaths')
    .then(async function (response) {
      if (response.ok) {
        response.json().then(function (result) {
          localStorage.setItem('downloadFilePaths', JSON.stringify(result));
        });
      }
      else {
        filePaths = Promise.reject(response);
      }
    })
    .catch(function (err) {
      showSnackbar(err, ' redBg');
    });
}

/**
 * Function to make an api call to get global data type list
 *
 * @return {null}
 */
const getGlobalDataTypeList = () => {
  fetch('/typemap', {
    method: 'GET',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }
  })
  .then(function (res) {
    if (res.ok) {
      res.json().then(function (result) {
        localStorage.setItem('globalDataTypeList', JSON.stringify(result));
      });
    }
    else {
      return Promise.reject(res);
    }
  }).catch(function (err) {
    showSnackbar(err, ' redBg');
  });
}

/**
 * Function to store each session by making an api call
 *
 * @param {string} dbType source db name
 * @return {null}
 */
const sessionRetrieval = (dbType) => {
  let sessionStorageArr;
  let sessionInfoResp;
  fetch('/session', {
    method: 'GET',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    }
  })
  .then(async function (res) {
    if (res.ok) {
      sessionInfoResp = await res.json();
      sessionStorageArr = JSON.parse(sessionStorage.getItem('sessionStorage'));
      if (sessionStorageArr == undefined)
        sessionStorageArr = [];
      sessionInfoResp.sourceDbType = dbType;
      sessionStorageArr.push(sessionInfoResp);
      sessionStorage.setItem('sessionStorage', JSON.stringify(sessionStorageArr));
    }
    else {
      sessionInfoResp = Promise.reject(res);
    }
  })
  .catch(function (err) {
    showSnackbar(err, ' redBg');
  });
}

/**
 * Function to select foreign key behaviour in each table (convert to interleave or use as is)
 *
 * @param {number} index table index
 * @return {null}
 */
const saveInterleaveHandler = (index) => {
  const radioValues = document.querySelectorAll('input[name="fks"]');
  let selectedValue;
  let interleaveApiCallResp = JSON.parse(localStorage.getItem('interleaveInfo'));
  for (const x of radioValues) {
    if (x.checked) {
      selectedValue = x.value;
      break;
    }
  }
  if (selectedValue == 'interleave') {
    console.log(index);
    console.log(interleaveApiCallResp[index]);
    if (interleaveApiCallResp[index].Possible == false) {
      showSnackbar('Cannot be Interleaved', ' redBg');
    }
    else if (interleaveApiCallResp[index].Possible == true) {
      showSnackbar('Successfully Interleaved', ' greenBg');
    }
  }
  else {
    showSnackbar('Response Saved', ' greenBg');
  }
}

/**
 * Function to get interleave info for each table
 *
 * @return {null}
 */
const getInterleaveInfo = async () => {
  let schemaObj = JSON.parse(localStorage.getItem('conversionReportContent'));
  let tablesNumber = Object.keys(schemaObj.SpSchema).length;
  let interleaveApiCallResp = [];
  let tableName;
  for (var i = 0; i < tablesNumber; i++) {
    tableName = Object.keys(schemaObj.ToSpanner)[i];
    interleaveApiCall = await fetch('/checkinterleave/table?table=' + tableName)
      .then(async function (response) {
        if (response.ok) {
          return response;
        }
        else {
          return Promise.reject(response);
        }
      })
      .catch(function (err) {
        showSnackbar(err, ' redBg');
      });
    interleaveApiCallResp[i] = await interleaveApiCall.json();
  }
  localStorage.setItem('interleaveInfo', JSON.stringify(interleaveApiCallResp));
}

/**
 * Function to store session info
 *
 * @param {string} driver database driver
 * @param {string} path file path
 * @param {string} fileName file name
 * @param {string} sourceDb source db name
 * @return {null}
 */
const storeResumeSessionId = (driver, path, fileName, sourceDb) => {
  localStorage.setItem('driver', driver);
  localStorage.setItem('path', path);
  localStorage.setItem('fileName', fileName);
  localStorage.setItem('sourceDb', sourceDb);
}

/**
 * Function to read file content when clicked on resume session
 *
 * @param {string} driver database driver
 * @param {string} path file path
 * @param {string} fileName file name
 * @param {string} sourceDb source db name
 * @return {null}
 */
const resumeSession = async (driver, path, fileName, sourceDb) => {
  let filePath = './' + fileName;
  let sourceTableFlag = '';
  readTextFile(filePath, function (text) {
    var data = JSON.parse(text);
    localStorage.setItem('conversionReportContent', JSON.stringify(data));
    sourceTableFlag = sourceDb;
  });
  await fetch('/session/resume', {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      "driver": driver,
      "path": path,
      "fileName": fileName
    })
  })
  .then(function (response) {
    if (response.ok) {
      console.log(response);
    }
    else {
      Promise.reject(response);
    }
  })
  .catch(function (err) {
    showSnackbar(err, ' redBg');
  });
  await ddlSummaryAndConversionApiCall();
  await getInterleaveInfo();
  jQuery('#importSchemaModal').modal('hide');
  const { component = ErrorComponent } = findComponentByPath(paths.resumeSession, routes) || {};
  component.render();
}

/**
 * Function to handle resume session click event
 *
 * @param {number} index session index in the array
 * @param {array} sessionArray array of objects containing session information
 * @return {null}
 */
const resumeSessionHandler = (index, sessionArray) => {
  storeResumeSessionId(sessionArray[index].driver, sessionArray[index].path, sessionArray[index].fileName, sessionArray[index].sourceDbType);
}

/**
 * Callback function to read file content
 *
 * @param {file}
 * @return {null}
 */
const readTextFile = (file, callback) => {
  let rawFile = new XMLHttpRequest();
  rawFile.overrideMimeType("application/json");
  rawFile.open("GET", file, true);
  rawFile.onreadystatechange = function () {
    if (rawFile.readyState == 4 && rawFile.status == "200") {
      callback(rawFile.responseText);
    }
  }
  rawFile.send(null);
}

/**
 * Function to check source schema while importing any file
 *
 * @param {string} val source db value (mysql or postgres)
 * @return {null}
 */
const importSourceSchema = (val) => {
  let sourceTableFlag = '';
  if (val === 'mysql') {
    sourceTableFlag = 'MySQL';
    localStorage.setItem('sourceDbName', sourceTableFlag);
  }
  else if (val === 'postgres') {
    sourceTableFlag = 'Postgres';
    localStorage.setItem('sourceDbName', sourceTableFlag);
  }
}

/**
 * Function to get paths and events generated from window
 *
 * @param {object} params object containing path and event as keys
 * @return {boolean}
 */
const renderComponent = (params) => {
  if ((params.path === paths.connectToDb || params.path === paths.loadDbDump) && params.event === 'load') {
    const { component = ErrorComponent } = findComponentByPath(location.hash.slice(1).toLowerCase() || paths.defaultPath, routes) || {};
    component.render();
  }
  else if (params.path === paths.importDb) {
    onImport();
  }
  else if (params.path === paths.resumeSession) {
    resumeSession(localStorage.getItem('driver'), localStorage.getItem('path'), localStorage.getItem('fileName'), localStorage.getItem('sourceDb'), window.event.type);
  }
  else {
    return false;
  }
  return true;
}

/**
 * Function to render home screen html
 *
 * @return {null}
 */
const homeScreen = () => {
  jQuery('#app').load('./main-screen.html');
}